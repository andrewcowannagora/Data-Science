{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red26\green26\blue26;\red255\green255\blue255;\red16\green60\blue192;
}
{\*\expandedcolortbl;;\cssrgb\c13333\c13333\c13333;\cssrgb\c100000\c100000\c100000;\cssrgb\c6667\c33333\c80000;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl240\sa200\partightenfactor0

\f0\fs20 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 ##########################################################################\cb1 \uc0\u8232 \cb3 #\'a0\cb1 \uc0\u8232 \cb3 # The point of this section is to introduce students to the packages of\'a0\cb1 \uc0\u8232 \cb3 # SNA and Igraph, to cover some basic R commands, to load and manage\'a0\cb1 \uc0\u8232 \cb3 # data, to generate graph visualizations, and to export the data for\'a0\cb1 \uc0\u8232 \cb3 # use elsewhere.\'a0\cb1 \uc0\u8232 \cb3 ##########################################################################\
\pard\pardeftab720\sl240\sa200\partightenfactor0
\cf2 \cb1 \uc0\u8232 \cb3 # To install all packages need for Social Network Analysis\'a0\cb1 \uc0\u8232 \cb3 # Labs in R, uncomment and run the following code:\cb1 \uc0\u8232 \cb3 # This will take 20-30 minutes.\'a0\cb1 \uc0\u8232 \cb3 # You only need to run this once per computer!\cb1 \uc0\u8232 \cb3 # while this is loading watch\'a0{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=ei3YEn8xUnI"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 https://www.youtube.com/watch?v=ei3YEn8xUnI}}\
source("{\field{\*\fldinst{HYPERLINK "http://sna.stanford.edu/setup.R"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 http://sna.stanford.edu/setup.R}}")\
\cb1 \uc0\u8232 \cb3 # To load the packages from , you need to call the "library"\cb1 \uc0\u8232 \cb3 # command. Note that you need to do this each session; packages\cb1 \uc0\u8232 \cb3 # don't load automatically by default (though you can set this\'a0\cb1 \uc0\u8232 \cb3 # as a preference if you'd like).\
# For this lab, we will use the "igraph" package.\cb1 \uc0\u8232 \cb3 # A manual is available at\'a0\cb1 \uc0\u8232 \cb3 #\'a0{\field{\*\fldinst{HYPERLINK "http://cran.r-project.org/web/packages/igraph/igraph.pdf"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 http://cran.r-project.org/web/packages/igraph/igraph.pdf}}.\cb1 \uc0\u8232 \cb3 library(igraph)\
# Sometimes, different packages overlap in functionality and\'a0\cb1 \uc0\u8232 \cb3 # cause unexpected behavior when both are loaded simultaneously.\cb1 \uc0\u8232 \cb3 # If you ever want to remove an existing library, use the\'a0\cb1 \uc0\u8232 \cb3 # "detach" command:\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # detach(package:igraph)\
# IMPORTANT NOTE: Unlike in most languages, R objects are numbered\cb1 \uc0\u8232 \cb3 # from 1 instead of 0, so if you want the first element in a\cb1 \uc0\u8232 \cb3 # vector, you would reference it by vector_name[1]. HOWEVER,\cb1 \uc0\u8232 \cb3 # igraph objects are numbered starting from 0. This can lead to\'a0\cb1 \uc0\u8232 \cb3 # lots of confusion, since it's not always obvious at first which\'a0\cb1 \uc0\u8232 \cb3 # objects are native to R and which belong to igraph.\
\cb1 \uc0\u8232 \cb3 ###\cb1 \uc0\u8232 \cb3 # 1. LOADING DATA\cb1 \uc0\u8232 \cb3 ###\
# The <- operator sets a variable equal to something. In this case,\cb1 \uc0\u8232 \cb3 # we will set a number of basic R data structures, called "data\'a0\cb1 \uc0\u8232 \cb3 # frames," to hold the contents of the files we will open.\'a0\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # read.table() is the most common R command for loading data from\cb1 \uc0\u8232 \cb3 # files in which values are in tabular format. The function loads\cb1 \uc0\u8232 \cb3 # the table into a data frame object, which is the basic data type\cb1 \uc0\u8232 \cb3 # for most operations in R. By default, R assumes that the table\cb1 \uc0\u8232 \cb3 # has no header and is delimited by any white space; these\cb1 \uc0\u8232 \cb3 # settings are fine for our purposes here.\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # One handy aspect of R is that you can read in data from a URL\'a0\cb1 \uc0\u8232 \cb3 # directly by referencing the URL in the read.table() function,\cb1 \uc0\u8232 \cb3 # as follows:\'a0\cb1 \uc0\u8232 \cb3 advice_data_frame <- read.table('{\field{\*\fldinst{HYPERLINK "http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt}}')\cb1 \uc0\u8232 \cb3 friendship_data_frame <- read.table('{\field{\*\fldinst{HYPERLINK "http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt}}')\cb1 \uc0\u8232 \cb3 reports_to_data_frame <- read.table('{\field{\*\fldinst{HYPERLINK "http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt}}')\
# If the files you want to work with are on your local machine,\'a0\cb1 \uc0\u8232 \cb3 # the easiest way to access them is to first set your working\'a0\cb1 \uc0\u8232 \cb3 # directory via the setwd() command, and then reference the\'a0\cb1 \uc0\u8232 \cb3 # files by name:\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # setwd('path/to/your_directory')\cb1 \uc0\u8232 \cb3 # your_data_frame <- read.table('your_file_name')\
# Note that when you set a variable equal to something, if all\'a0\cb1 \uc0\u8232 \cb3 # goes well R will not provide any feedback. To see the data we\cb1 \uc0\u8232 \cb3 # just loaded, it's necessary to call the variables directly.\cb1 \uc0\u8232 \cb3 advice_data_frame\
# Since this is a bit long, we can see just the top six rows via\cb1 \uc0\u8232 \cb3 # head()...\cb1 \uc0\u8232 \cb3 head(friendship_data_frame)\
# ... or the bottom six rows via tail().\cb1 \uc0\u8232 \cb3 tail(reports_to_data_frame)\
# To view your data in a spreadsheet-like window, use the command 'fix()'.\'a0\cb1 \uc0\u8232 \cb3 fix(reports_to_data_frame)\
# The attribute data for this section is in a comma-separated-value\cb1 \uc0\u8232 \cb3 # (CSV) file. read.csv() loads a CSV file into a data frame\cb1 \uc0\u8232 \cb3 # object. In this case, we do have a header row, so we set\cb1 \uc0\u8232 \cb3 # header=T, which tells R that the first row of data contains\cb1 \uc0\u8232 \cb3 # column names.\cb1 \uc0\u8232 \cb3 attributes <- read.csv('{\field{\*\fldinst{HYPERLINK "http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-Attributes.csv"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-Attributes.csv}}', header=T)\cb1 \uc0\u8232 \cb3 attributes\
# Other commands may be used to load data from files in different\'a0\cb1 \uc0\u8232 \cb3 # formats. read.delim() is a general function for loading any\cb1 \uc0\u8232 \cb3 # delimited text file. The default is tab-delimited, but this can\'a0\cb1 \uc0\u8232 \cb3 # be overridden by setting the "sep" parameter. For example:\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # f <- read.delim("tab_delimited_file.txt")\cb1 \uc0\u8232 \cb3 # f <- read.delim("colon_delimited_file.txt", sep=':')\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # The 'foreign' package will allow you to read a few other\'a0\cb1 \uc0\u8232 \cb3 # custom data types, such as SPSS files via read.spss() and\'a0\cb1 \uc0\u8232 \cb3 # STATA files via read.dta().\
# When data files are part of an R package you can read them as\'a0\cb1 \uc0\u8232 \cb3 # follows:\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # data(kracknets, package = "NetData")\
# In the future, we will load data this way. However, it is useful\'a0\cb1 \uc0\u8232 \cb3 # to get a sense of how things often must be done in R.\
\cb1 \uc0\u8232 \cb3 ###\cb1 \uc0\u8232 \cb3 # 2.2. LOADING GRAPHS\cb1 \uc0\u8232 \cb3 ###\
# For convenience, we can assign column names to our newly\'a0\cb1 \uc0\u8232 \cb3 # imported data frames. c() is a common generic R function that\'a0\cb1 \uc0\u8232 \cb3 # combines its arguments into a single vector.\cb1 \uc0\u8232 \cb3 colnames(advice_data_frame) <- c('ego', 'alter', 'advice_tie')\cb1 \uc0\u8232 \cb3 head(advice_data_frame)\
colnames(friendship_data_frame) <- c('ego', 'alter', 'friendship_tie')\cb1 \uc0\u8232 \cb3 head(friendship_data_frame)\
colnames(reports_to_data_frame) <- c('ego', 'alter', 'reports_to_tie')\cb1 \uc0\u8232 \cb3 head(reports_to_data_frame)\
# Take a look at each data frame using the 'fix()" function. Note that you'll\'a0\cb1 \uc0\u8232 \cb3 # need to close each fix window before R will evaluate the next line of code.\cb1 \uc0\u8232 \cb3 fix(advice_data_frame)\cb1 \uc0\u8232 \cb3 fix(friendship_data_frame)\cb1 \uc0\u8232 \cb3 fix(reports_to_data_frame)\
# Before we merge these data, we need to make sure 'ego' and 'alter' are the\cb1 \uc0\u8232 \cb3 # same across data sets. We can compare each row using the == syntax.\'a0\cb1 \uc0\u8232 \cb3 # The command below should return TRUE for every row if all ego rows\cb1 \uc0\u8232 \cb3 # are the same for advice and friendship:\cb1 \uc0\u8232 \cb3 advice_data_frame$ego == friendship_data_frame$ego\
# That's a lot of output to sort through. Instead, we can just have R return\'a0\cb1 \uc0\u8232 \cb3 # which row entries are not equal using the syntax below:\cb1 \uc0\u8232 \cb3 which(advice_data_frame$ego != friendship_data_frame$ego)\
# Repeat for other variables\cb1 \uc0\u8232 \cb3 which(advice_data_frame$alter != friendship_data_frame$alter)\cb1 \uc0\u8232 \cb3 which(reports_to_data_frame$alter != friendship_data_frame$alter)\cb1 \uc0\u8232 \cb3 which(reports_to_data_frame$ego != friendship_data_frame$ego)\
# Now that we've verified they are all the same, we can combine them into\'a0\cb1 \uc0\u8232 \cb3 # a single data frame.\'a0\cb1 \uc0\u8232 \cb3 krack_full_data_frame <- cbind(advice_data_frame,\'a0\cb1 \uc0\u8232 \cb3 friendship_data_frame$friendship_tie,\'a0\cb1 \uc0\u8232 \cb3 reports_to_data_frame$reports_to_tie)\cb1 \uc0\u8232 \cb3 head(krack_full_data_frame)\
# Notice that the last two variable names are now\'a0\cb1 \uc0\u8232 \cb3 # "reports_to_data_frame$reports_to_tie"\cb1 \uc0\u8232 \cb3 # and "friendship_data_frame$friendship_tie".\'a0\cb1 \uc0\u8232 \cb3 # That's a little long. We can rename them\cb1 \uc0\u8232 \cb3 # as follows:\
names(krack_full_data_frame)[4:5] <- c("friendship_tie",\'a0\cb1 \uc0\u8232 \cb3 "reports_to_tie")\'a0\cb1 \uc0\u8232 \cb3 head(krack_full_data_frame)\
# Another way to build the data frame is to use R's\'a0\cb1 \uc0\u8232 \cb3 # data.frame syntax from the start:\cb1 \uc0\u8232 \cb3 krack_full_data_frame <- data.frame(ego = advice_data_frame[,1],\cb1 \uc0\u8232 \cb3 alter = advice_data_frame[,2],\cb1 \uc0\u8232 \cb3 advice_tie = advice_data_frame[,3],\cb1 \uc0\u8232 \cb3 friendship_tie = friendship_data_frame[,3],\'a0\cb1 \uc0\u8232 \cb3 reports_to_tie = reports_to_data_frame[,3])\cb1 \uc0\u8232 \cb3 head(krack_full_data_frame)\
\cb1 \uc0\u8232 \cb3 # Now let's move on to some data processing.\
# Reduce to non-zero edges so that the edge list only contains\cb1 \uc0\u8232 \cb3 # actual ties of some type.\cb1 \uc0\u8232 \cb3 krack_full_nonzero_edges <- subset(krack_full_data_frame,\'a0\cb1 \uc0\u8232 \cb3 (advice_tie > 0 | friendship_tie > 0 | reports_to_tie > 0))\cb1 \uc0\u8232 \cb3 head(krack_full_nonzero_edges)\
# Now we can import our data into a "graph" object using igraph's\'a0\cb1 \uc0\u8232 \cb3 # graph.data.frame() function. Coercing the data into a graph\cb1 \uc0\u8232 \cb3 # object is what allows us to perform network-analysis techniques.\cb1 \uc0\u8232 \cb3 krack_full <- graph.data.frame(krack_full_nonzero_edges)\'a0\cb1 \uc0\u8232 \cb3 summary(krack_full)\
# By default, graph.data.frame() treats the first two columns of\'a0\cb1 \uc0\u8232 \cb3 # a data frame as an edge list and any remaining columns as\'a0\cb1 \uc0\u8232 \cb3 # edge attributes. Thus, the 232 edges appearing in the summary()\cb1 \uc0\u8232 \cb3 # output refer to the 232 pairs of vertices that are joined by\'a0\cb1 \uc0\u8232 \cb3 # *any type* of tie. The tie types themselves are listed as edge\'a0\cb1 \uc0\u8232 \cb3 # attributes.\
# To get a vector of edges for a specific type of tie, use the\'a0\cb1 \uc0\u8232 \cb3 # get.edge.attribute() function.\cb1 \uc0\u8232 \cb3 get.edge.attribute(krack_full, 'advice_tie')\cb1 \uc0\u8232 \cb3 get.edge.attribute(krack_full, 'friendship_tie')\cb1 \uc0\u8232 \cb3 get.edge.attribute(krack_full, 'reports_to_tie')\
# If you would like to symmetrize the network, making all\'a0\cb1 \uc0\u8232 \cb3 # asymmetric ties symmetric, use the as.undirected()\cb1 \uc0\u8232 \cb3 # function:\'a0\cb1 \uc0\u8232 \cb3 krack_full_symmetrized <- as.undirected(krack_full, mode='collapse')\cb1 \uc0\u8232 \cb3 summary(krack_full_symmetrized)\
\'a0\
###\cb1 \uc0\u8232 \cb3 # 3. ADDING VERTEX ATTRIBUTES TO A GRAPH OBJECT\cb1 \uc0\u8232 \cb3 ###\
# One way to add the attributes to your graph object is to iterate\cb1 \uc0\u8232 \cb3 # through each attribute and each vertex. This means that we will\cb1 \uc0\u8232 \cb3 # add one attribute at a time to each vertex in the network.\cb1 \uc0\u8232 \cb3 #\cb1 \uc0\u8232 \cb3 # V(krack_full) returns a list of the IDs of each vertex in the\'a0\cb1 \uc0\u8232 \cb3 # graph. names(attributes) returns a list of the column names in\cb1 \uc0\u8232 \cb3 # the attributes table. The double-for loop tells R to repeat the\cb1 \uc0\u8232 \cb3 # code between the brackets once for each attribute and once for\cb1 \uc0\u8232 \cb3 # each vertex.\cb1 \uc0\u8232 \cb3 for (i in V(krack_full)) \{\cb1 \uc0\u8232 \cb3 for (j in names(attributes)) \{\cb1 \uc0\u8232 \cb3 krack_full <- set.vertex.attribute(krack_full,\'a0\cb1 \uc0\u8232 \cb3 j,\'a0\cb1 \uc0\u8232 \cb3 index = i,\'a0\cb1 \uc0\u8232 \cb3 attributes[i + 1, j])\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 \}\
# A shorter way is to just read in attribute names when you\cb1 \uc0\u8232 \cb3 # create the graph object:\
# First create a vector of vertex labels, in this case 1:n\cb1 \uc0\u8232 \cb3 attributes = cbind(1:length(attributes[,1]), attributes)\
krack_full <- graph.data.frame(d = krack_full_nonzero_edges,\'a0\cb1 \uc0\u8232 \cb3 vertices = attributes)\
# Note that we now have 'AGE,' 'TENURE,' 'LEVEL,' and 'DEPT'\cb1 \uc0\u8232 \cb3 # listed alongside 'name' as vertex attributes.\cb1 \uc0\u8232 \cb3 summary(krack_full)\
# We can see a list of the values for a given attribute for all of\cb1 \uc0\u8232 \cb3 # the actors in the network.\cb1 \uc0\u8232 \cb3 get.vertex.attribute(krack_full, 'AGE')\cb1 \uc0\u8232 \cb3 get.vertex.attribute(krack_full, 'TENURE')\cb1 \uc0\u8232 \cb3 get.vertex.attribute(krack_full, 'LEVEL')\cb1 \uc0\u8232 \cb3 get.vertex.attribute(krack_full, 'DEPT')\
\cb1 \uc0\u8232 \cb3 ###\cb1 \uc0\u8232 \cb3 # 4. VISUALIZE THE NETWORKS\cb1 \uc0\u8232 \cb3 ###\
# We can use R's general-purpose plot() method to generate custom\cb1 \uc0\u8232 \cb3 # visualizations of the network.\
# R only lets us look at one plot at a time. To make our work easier\cb1 \uc0\u8232 \cb3 # we will save our plots as PDF files. To jus create a plot execute\'a0\cb1 \uc0\u8232 \cb3 # the code between the PDF function and "dev.off()".\
# In order to save PDF files we must tell R where to put them. We do\cb1 \uc0\u8232 \cb3 # this with the setwd() command. You must put the full path to the\cb1 \uc0\u8232 \cb3 # folder where you will output the files here.\
# In OS X you can get this information by selecting the folder, right\cb1 \uc0\u8232 \cb3 # clicking and selecting "Get Info." The path is listed under "Where."\
# In Windows you can get this information by selecting the folder, right\cb1 \uc0\u8232 \cb3 # clicking and selecting "Properties." The path information is listed\'a0\cb1 \uc0\u8232 \cb3 # "location".\
# example: setwd("/Users/hashmat/Desktop/lab_1")\cb1 \uc0\u8232 \cb3 setwd("")\
# First, let's plot the network with all possible ties.\cb1 \uc0\u8232 \cb3 plot(krack_full)\
\cb1 \uc0\u8232 \cb3 # This is a bit of a jumble, so let's look at the networks for\cb1 \uc0\u8232 \cb3 # single edge types.\
# advice only\cb1 \uc0\u8232 \cb3 krack_advice_only <- delete.edges(krack_full,\'a0\cb1 \uc0\u8232 \cb3 E(krack_full)[get.edge.attribute(krack_full,\cb1 \uc0\u8232 \cb3 name = "advice_tie") == 0])\cb1 \uc0\u8232 \cb3 summary(krack_advice_only)\cb1 \uc0\u8232 \cb3 plot(krack_advice_only)\
\cb1 \uc0\u8232 \cb3 # friendship only\cb1 \uc0\u8232 \cb3 krack_friendship_only <- delete.edges(krack_full,\'a0\cb1 \uc0\u8232 \cb3 E(krack_full)[get.edge.attribute(krack_full,\'a0\cb1 \uc0\u8232 \cb3 name = "friendship_tie") == 0])\cb1 \uc0\u8232 \cb3 summary(krack_friendship_only)\cb1 \uc0\u8232 \cb3 plot(krack_friendship_only)\
# reports-to only\cb1 \uc0\u8232 \cb3 krack_reports_to_only <- delete.edges(krack_full,\'a0\cb1 \uc0\u8232 \cb3 E(krack_full)[get.edge.attribute(krack_full,\'a0\cb1 \uc0\u8232 \cb3 name = "reports_to_tie") == 0])\cb1 \uc0\u8232 \cb3 summary(krack_reports_to_only)\cb1 \uc0\u8232 \cb3 plot(krack_reports_to_only)\
# Still kind of messy, so let's clean things up a bit. For\'a0\cb1 \uc0\u8232 \cb3 # simplicity, we'll focus on reports_to ties for now.\
# First, we can optimize the layout by applying the layout\'a0\cb1 \uc0\u8232 \cb3 # algorithm to the specific set of ties we care about. Here\'a0\cb1 \uc0\u8232 \cb3 # we'll use Fruchterman-Rheingold; other options are\'a0\cb1 \uc0\u8232 \cb3 # described in the igraph help page for "layout," which\'a0\cb1 \uc0\u8232 \cb3 # can be accessed by entering ?layout.\
reports_to_layout <- layout.fruchterman.reingold(krack_reports_to_only)\cb1 \uc0\u8232 \cb3 plot(krack_reports_to_only,\'a0\cb1 \uc0\u8232 \cb3 layout=reports_to_layout)\
# Now let's color-code vertices by department and clean up the\'a0\cb1 \uc0\u8232 \cb3 # plot by removing vertex labels and shrinking the arrow size.\'a0\cb1 \uc0\u8232 \cb3 dept_vertex_colors = get.vertex.attribute(krack_full,"DEPT")\cb1 \uc0\u8232 \cb3 colors = c('Black', 'Red', 'Blue', 'Yellow', 'Green')\cb1 \uc0\u8232 \cb3 dept_vertex_colors[dept_vertex_colors == 0] = colors[1]\cb1 \uc0\u8232 \cb3 dept_vertex_colors[dept_vertex_colors == 1] = colors[2]\cb1 \uc0\u8232 \cb3 dept_vertex_colors[dept_vertex_colors == 2] = colors[3]\cb1 \uc0\u8232 \cb3 dept_vertex_colors[dept_vertex_colors == 3] = colors[4]\'a0\cb1 \uc0\u8232 \cb3 dept_vertex_colors[dept_vertex_colors == 4] = colors[5]\cb1 \uc0\u8232 \u8232 \cb3 plot(krack_reports_to_only,\'a0\cb1 \uc0\u8232 \cb3 layout=reports_to_layout,\'a0\cb1 \uc0\u8232 \cb3 vertex.color=dept_vertex_colors,\'a0\cb1 \uc0\u8232 \cb3 vertex.label=NA,\'a0\cb1 \uc0\u8232 \cb3 edge.arrow.size=.5)\cb1 \uc0\u8232 \cb3 # Now let's set the vertex size by tenure.\cb1 \uc0\u8232 \cb3 tenure_vertex_sizes = get.vertex.attribute(krack_full,"TENURE")\
plot(krack_reports_to_only,\'a0\cb1 \uc0\u8232 \cb3 layout=reports_to_layout,\'a0\cb1 \uc0\u8232 \cb3 vertex.color=dept_vertex_colors,\'a0\cb1 \uc0\u8232 \cb3 vertex.label=NA,\'a0\cb1 \uc0\u8232 \cb3 edge.arrow.size=.5,\cb1 \uc0\u8232 \cb3 vertex.size=tenure_vertex_sizes)\
# Now let's incorporate additional tie types. We'll use the\'a0\cb1 \uc0\u8232 \cb3 # layout generated by the reports-to ties but overlay the\'a0\cb1 \uc0\u8232 \cb3 # advice and friendship ties in red and blue.\
tie_type_colors = c(rgb(1,0,0,.5), rgb(0,0,1,.5), rgb(0,0,0,.5))\cb1 \uc0\u8232 \cb3 E(krack_full)$color[ E(krack_full)$advice_tie==1 ] = tie_type_colors[1]\cb1 \uc0\u8232 \cb3 E(krack_full)$color[ E(krack_full)$friendship_tie==1 ] = tie_type_colors[2]\cb1 \uc0\u8232 \cb3 E(krack_full)$color[ E(krack_full)$reports_to_tie==1 ] = tie_type_colors[3]\cb1 \uc0\u8232 \cb3 E(krack_full)$arrow.size=.5\'a0\cb1 \uc0\u8232 \cb3 V(krack_full)$color = dept_vertex_colors\cb1 \uc0\u8232 \cb3 V(krack_full)$frame = dept_vertex_colors\
plot(krack_full,\'a0\cb1 \uc0\u8232 \cb3 layout=reports_to_layout,\'a0\cb1 \uc0\u8232 \cb3 vertex.color=dept_vertex_colors,\'a0\cb1 \uc0\u8232 \cb3 vertex.label=NA,\'a0\cb1 \uc0\u8232 \cb3 edge.arrow.size=.5,\cb1 \uc0\u8232 \cb3 vertex.size=tenure_vertex_sizes)\
\cb1 \uc0\u8232 \cb3 # Add a legend. Note that the plot window must be open for this to\'a0\cb1 \uc0\u8232 \cb3 # work.\cb1 \uc0\u8232 \cb3 legend(1,\'a0\cb1 \uc0\u8232 \cb3 1.25,\cb1 \uc0\u8232 \cb3 legend = c('Advice',\'a0\cb1 \uc0\u8232 \cb3 'Friendship',\cb1 \uc0\u8232 \cb3 'Reports To'),\'a0\cb1 \uc0\u8232 \cb3 col = tie_type_colors,\'a0\cb1 \uc0\u8232 \cb3 lty=1,\cb1 \uc0\u8232 \cb3 cex = .7)\
# Another option for visualizing different network ties relative\'a0\cb1 \uc0\u8232 \cb3 # to one another is to overlay the edges from one tie type on the\'a0\cb1 \uc0\u8232 \cb3 # structure generated by another tie type. Here we can use the\cb1 \uc0\u8232 \cb3 # reports-to layout but show the friendship ties:\
plot(krack_friendship_only,\'a0\cb1 \uc0\u8232 \cb3 layout=reports_to_layout,\'a0\cb1 \uc0\u8232 \cb3 vertex.color=dept_vertex_colors,\'a0\cb1 \uc0\u8232 \cb3 vertex.label=NA,\'a0\cb1 \uc0\u8232 \cb3 edge.arrow.size=.5,\cb1 \uc0\u8232 \cb3 vertex.size=tenure_vertex_sizes,\'a0\cb1 \uc0\u8232 \cb3 main='Krackhardt High-Tech Managers')\
\'a0\
###\cb1 \uc0\u8232 \cb3 # 5. EXPORT THE NETWORK\cb1 \uc0\u8232 \cb3 ###\
# The write.graph() function exports a graph object in various\cb1 \uc0\u8232 \cb3 # formats readable by other programs. There is no explicit\cb1 \uc0\u8232 \cb3 # option for a UCINET data type, but you can export the graph\cb1 \uc0\u8232 \cb3 # as a Pajek object by setting the 'format' parameter to 'pajek.'\cb1 \uc0\u8232 \cb3 # Note that the file will appear in whichever directory is set\'a0\cb1 \uc0\u8232 \cb3 # as the default in R's preferences, unless you previously\'a0\cb1 \uc0\u8232 \cb3 # changed this via setwd().\cb1 \uc0\u8232 \cb3 # These will be saved in the following directory.\cb1 \uc0\u8232 \cb3 getwd()\
write.graph(krack_full, file='krack_full.dl', format="pajek")\
# For a more general file type (e.g., importable to Excel),\cb1 \uc0\u8232 \cb3 # use the "edgelist" format. Note that neither of these will\cb1 \uc0\u8232 \cb3 # write the attributes; only the ties are maintained.\cb1 \uc0\u8232 \cb3 write.graph(krack_full, file='krack_full.txt', format="edgelist")}